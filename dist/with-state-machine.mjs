class t{constructor(t){this.machine=t}get initialState(){return this.machine.initial||Object.keys(this.machine.states)[0]}transition(t,e){return this.machine.states[t].on[e]}}function withStateMachine(e,i){return{...i,created(){this._stateMachineDefinition=e,this._stateMachine=new t(e),this.initialState=this._stateMachine.initialState,this.state={context:{},matches(t){return t===this.value},value:this.initialState},this.setState=(t,e)=>{if(!t||"object"!=typeof t)return;const i=this.updated;e&&(this.updated=()=>{e.call(this),this.updated=i||void 0}),this.status="transaction";for(const e in t)"value"===e?this.state[e]=t[e]:this.state.context[e]&&this.state.context[e]===t[e]||(this.state.context[e]=t[e]);this.status="render",this._processRender()},i.created&&i.created.call(this)},send(t){let e,i;if("string"==typeof t)e=t;else{const{type:s,...a}=t;e=s,i=a}const{value:s}=this.state,a=this._stateMachine.transition(s,e)||s,n="object"==typeof a&&a.target?a.target:a,h="object"==typeof a&&a.action?a.action:a,c=this._stateMachineDefinition.actions&&this._stateMachineDefinition.actions[h]?()=>this._stateMachineDefinition.actions[h].call(this,i):()=>{};this.setState({value:n},c)}}}export{withStateMachine};
