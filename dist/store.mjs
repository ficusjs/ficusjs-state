class t{constructor(t,e,s={}){this.namespace=t,this.storage=e,this.options=s,this._init()}_init(){if("performance"in globalThis&&this.options.clearOnReload){const t=globalThis.performance.getEntriesByType("navigation").map((t=>t.type));this.lastUpdated()&&t.includes("reload")&&this.removeState()}}setState(t){t?(this.storage.setItem(`${this.namespace}:state`,this._normalizeState(t)),this.storage.setItem(`${this.namespace}:lastUpdated`,(new Date).getTime().toString())):this.removeState()}_normalizeState(t){return"object"==typeof t&&this.options.saveState&&"function"==typeof this.options.saveState?JSON.stringify(this.options.saveState(t)):"string"!=typeof t?JSON.stringify(t):t}getState(){const t=this.storage.getItem(`${this.namespace}:state`);return t?JSON.parse(t):void 0}lastUpdated(){const t=this.storage.getItem(`${this.namespace}:lastUpdated`);return t?parseInt(t,10):void 0}removeState(){this.storage.removeItem(`${this.namespace}:state`),this.storage.removeItem(`${this.namespace}:lastUpdated`)}}class e{constructor(e){const s=this;s.state={},s.getterCache={},s.status="resting",s.transaction=!1,s.transactionCache={},s.callbacks=[],this._processActions(e);let a=e.initialState||{};if(s.copyOfInitialState=s._copyValue(a),s.ttl=-1,s.lastUpdatedState={},e.ttl&&(s.ttl=e.ttl,Object.keys(s.copyOfInitialState).forEach((t=>s.lastUpdatedState[t]=(new Date).getTime()))),e.persist){s.persist="string"==typeof e.persist?function(e,s="session",a){return new t(e,"local"===s?globalThis.localStorage:globalThis.sessionStorage,a)}(e.persist):e.persist;const i=s.persist.getState(),n=s.persist.lastUpdated();i&&n&&(-1===s.ttl||s._lastUpdatedTimeDiff(n)<s.ttl)&&(a=i)}this._processState(a)}_processActions(t){const e=this,s=Object.keys(t);s.length&&s.forEach((s=>{e[s]||"function"!=typeof t[s]||(e[s]=t[s].bind(e))}))}_processState(t){const e=this;e.state=new Proxy(t,{set:(t,s,a)=>(e.transaction&&!e.transactionCache[s]&&(e.transactionCache[s]=e._copyValue(t[s])),t[s]=a,e.lastUpdatedState[s]=(new Date).getTime(),e.getterCache={},e.transaction||(e.persist&&e.persist.setState(e.state),e.status="resting",e._processCallbacks(e.state)),!0),get:(t,s)=>e.ttl>-1&&e._lastUpdatedTimeDiff(e.lastUpdatedState[s])>e.ttl?(e.persist&&e.persist.removeState(),e.copyOfInitialState[s]):t[s]})}_lastUpdatedTimeDiff(t){return Math.round((new Date).getTime()-t)}setState(t){const setter=t=>{if(!t||"object"!=typeof t)return;const e=this.transaction;e||(this.transactionCache={},this.transaction=!0);for(const e in t)this.state[e]&&this.state[e]===t[e]||(this.state[e]=t[e]);e||(this.transaction=!1,this.persist&&this.persist.setState(this.state),this._processCallbacks(this.state))},e=t(this.state);var s;"object"!=typeof(s=e)&&"function"!=typeof s||"function"!=typeof s.then?setter(e):e.then(setter)}getState(t){if(t&&("string"==typeof t||"function"==typeof t)){if(!this.getterCache[t]){let e;if("function"==typeof t)e=t(this.state);else{e=(Array.isArray(t)?t:t.match(/([^[.\]])+/g)).reduce(((t,e)=>t&&t[e]),this.state)}if(null==e)return;this.getterCache[t]=e}return this.getterCache[t]}}_processCallbacks(t){return!!this.callbacks.length&&(this.callbacks.forEach((e=>e(t))),!0)}subscribe(t){if("function"!=typeof t)throw new Error("Dude, you can only subscribe to store changes with a valid function");return this.callbacks.includes(t)||this.callbacks.push(t),()=>{this.callbacks=this.callbacks.filter((e=>e!==t))}}_copyValue(t){return t?JSON.parse(JSON.stringify(t)):t}clear(t=!0){this.getterCache={},this.transactionCache={},this.lastUpdatedState={},this.persist&&this.persist.removeState(),this.transaction=!0,this.status="clear";const e=this._copyValue(this.copyOfInitialState);for(const t in e)this.state[t]=e[t];this.transaction=!1,this.status="resting",t&&this._processCallbacks(this.state)}}export{e as Store};
