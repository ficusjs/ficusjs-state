{"version":3,"file":"store.mjs","sources":["../src/base-persist.mjs","../src/store.mjs","../src/util/is-promise.mjs"],"sourcesContent":["class BasePersist {\n  /**\n   * Create an instance of persistence with the unique namespace identifier\n   * @param {string} namespace\n   * @param {object} storage\n   * @param {object} options\n   */\n  constructor (namespace, storage, options = {}) {\n    this.namespace = namespace\n    this.storage = storage\n    this.options = options\n    this._init()\n  }\n\n  /**\n   * Private method for initializing\n   * @private\n   */\n  _init () {\n    if ('performance' in globalThis && this.options.clearOnReload) {\n      // @ts-ignore\n      const entries = globalThis.performance.getEntriesByType('navigation').map(e => e.type)\n      const lastUpdated = this.lastUpdated()\n      if (lastUpdated && entries.includes('reload')) {\n        this.removeState()\n      }\n    }\n  }\n\n  /**\n   * Set state in the persistence store\n   * @param {*} state\n   */\n  setState (state) {\n    if (state) {\n      this.storage.setItem(`${this.namespace}:state`, this._normalizeState(state))\n      this.storage.setItem(`${this.namespace}:lastUpdated`, new Date().getTime().toString())\n    } else {\n      this.removeState()\n    }\n  }\n\n  /**\n   * Normalize state before persisting\n   * @param state\n   * @returns {string}\n   * @private\n   */\n  _normalizeState (state) {\n    if (typeof state === 'object' && (this.options.saveState && typeof this.options.saveState === 'function')) {\n      return JSON.stringify(this.options.saveState(state))\n    } else if (typeof state !== 'string') {\n      return JSON.stringify(state)\n    }\n    return state\n  }\n\n  /**\n   * Get state from the persistence store\n   * @returns {*}\n   */\n  getState () {\n    const state = this.storage.getItem(`${this.namespace}:state`)\n    return state ? JSON.parse(state) : undefined\n  }\n\n  /**\n   * Get the last updated time in milliseconds since the Unix Epoch\n   * @returns {number}\n   */\n  lastUpdated () {\n    const lastUpdated = this.storage.getItem(`${this.namespace}:lastUpdated`)\n    return lastUpdated ? parseInt(lastUpdated, 10) : undefined\n  }\n\n  /**\n   * Remove state from the persistence store\n   */\n  removeState () {\n    this.storage.removeItem(`${this.namespace}:state`)\n    this.storage.removeItem(`${this.namespace}:lastUpdated`)\n  }\n}\n\n/**\n * Function to create persistence for the store\n * @param {string} namespace\n * @param {string} [storageName]\n * @param {object} [options]\n * @returns {BasePersist}\n */\nfunction createPersist (namespace, storageName = 'session', options) {\n  if (storageName === 'local') {\n    return new BasePersist(namespace, globalThis.localStorage, options)\n  }\n  return new BasePersist(namespace, globalThis.sessionStorage, options)\n}\n\nexport { BasePersist, createPersist }\n","import { createPersist } from './base-persist.mjs'\nimport { isPromise } from './util/is-promise.mjs'\n\nexport class Store {\n  constructor (options) {\n    const self = this\n\n    // An object to hold our state\n    self.state = {}\n\n    // create a getter cache\n    self.getterCache = {}\n\n    // A status enum to set during actions and mutations\n    self.status = 'resting'\n\n    // Transactional flag for batch actions/mutations without triggering re-rendering\n    self.transaction = false\n    self.transactionCache = {}\n\n    // We store callbacks for when the state changes in here\n    self.callbacks = []\n\n    // Allow actions to be added to this instance\n    this._processActions(options)\n\n    // initial state values\n    let initialState = options.initialState || {}\n    self.copyOfInitialState = self._copyValue(initialState)\n\n    // time to live settings\n    self.ttl = -1\n    self.lastUpdatedState = {}\n    if (options.ttl) {\n      self.ttl = options.ttl\n      Object.keys(self.copyOfInitialState).forEach(k => (self.lastUpdatedState[k] = new Date().getTime()))\n    }\n\n    // persistence\n    self.persist = undefined\n    if (options.persist) {\n      self.persist = typeof options.persist === 'string' ? createPersist(options.persist) : options.persist\n\n      // check for initial state\n      const initState = self.persist.getState()\n      const lastUpdated = self.persist.lastUpdated()\n      if (initState &&\n        lastUpdated &&\n        (self.ttl === -1 || self._lastUpdatedTimeDiff(lastUpdated) < self.ttl)) {\n        initialState = initState\n      }\n    }\n\n    // set-up state\n    this._processState(initialState)\n  }\n\n  /**\n   * Attach actions to the store instance\n   * @param {object} options\n   * @private\n   */\n  _processActions (options) {\n    const self = this\n    const keys = Object.keys(options)\n    if (!keys.length) return\n\n    // Run through and bind to the component instance\n    keys.forEach(key => {\n      if (!self[key] && typeof options[key] === 'function') {\n        self[key] = options[key].bind(self)\n      }\n    })\n  }\n\n  /**\n   * Set-up the internal state object\n   * @param {object} initialState\n   * @private\n   */\n  _processState (initialState) {\n    const self = this\n    // Set our state to be a Proxy. We are setting the default state by\n    // checking the params and defaulting to an empty object if no default\n    // state is passed in\n    self.state = new Proxy(initialState, {\n      set (state, key, value) {\n        // cache first value changed if we're in transaction mode\n        if (self.transaction && !self.transactionCache[key]) {\n          self.transactionCache[key] = self._copyValue(state[key])\n        }\n\n        // Set the value as we would normally\n        state[key] = value\n        self.lastUpdatedState[key] = new Date().getTime()\n\n        // clear the getter cache\n        self.getterCache = {}\n\n        if (!self.transaction) {\n          // if we have persistence pass the new state to it\n          if (self.persist) {\n            self.persist.setState(self.state)\n          }\n\n          // Reset the status ready for the next operation\n          self.status = 'resting'\n\n          // Fire off our callback processor because if there's listeners,\n          // they're going to want to know that something has changed\n          self._processCallbacks(self.state)\n        }\n\n        return true\n      },\n      get (state, key) {\n        if (self.ttl > -1 && self._lastUpdatedTimeDiff(self.lastUpdatedState[key]) > self.ttl) {\n          if (self.persist) {\n            self.persist.removeState()\n          }\n          return self.copyOfInitialState[key]\n        }\n        return state[key]\n      }\n    })\n  }\n\n  /**\n   * Last updated state time difference in seconds\n   * @param {number} value\n   * @returns {number}\n   * @private\n   */\n  _lastUpdatedTimeDiff (value) {\n    return Math.round((new Date().getTime() - value))\n  }\n\n  /**\n   * A method to set state\n   * @param {Function} stateFn\n   * @memberOf Store\n   */\n  setState (stateFn) {\n    const setter = data => {\n      if (!data || typeof data !== 'object') return\n\n      const isExistingTransaction = this.transaction\n\n      // begin a transaction\n      if (!isExistingTransaction) {\n        this.transactionCache = {}\n        this.transaction = true\n      }\n\n      for (const key in data) {\n        if (!this.state[key] || (this.state[key] !== data[key])) this.state[key] = data[key]\n      }\n\n      // end the transaction\n      if (!isExistingTransaction) {\n        this.transaction = false\n\n        // if we have persistence pass the new state to it\n        if (this.persist) {\n          this.persist.setState(this.state)\n        }\n\n        this._processCallbacks(this.state)\n      }\n    }\n\n    // Get a new version of the state by running the mutation and storing the result of it\n    const res = stateFn(this.state)\n\n    // set the state\n    isPromise(res) ? res.then(setter) : setter(res)\n  }\n\n  /**\n   * A method to return state\n   * @param {string|function} key\n   * @returns {*}\n   */\n  getState (key) {\n    // if key is not defined\n    if (!key || (typeof key !== 'string' && typeof key !== 'function')) return undefined\n\n    // check the getter cache first\n    if (!this.getterCache[key]) {\n      let result\n      if (typeof key === 'function') {\n        result = key(this.state)\n      } else {\n        // Check if path is string or array. Regex : ensure that we do not have '.' and brackets.\n        // Regex explained: https://regexr.com/58j0k\n        const keyArray = Array.isArray(key) ? key : key.match(/([^[.\\]])+/g)\n\n        // get the result\n        // @ts-ignore\n        result = keyArray.reduce((prevObj, key) => prevObj && prevObj[key], this.state)\n      }\n\n      // if the result is not defined\n      if (result == null) return undefined\n\n      // cache the result\n      this.getterCache[key] = result\n    }\n\n    return this.getterCache[key]\n  }\n\n  /**\n   * Fire off each callback that's run whenever the state changes\n   * We pass in some data as the one and only parameter.\n   * Returns a boolean indicating if the callbacks were called\n   * @private\n   * @param {object} data\n   * @returns {boolean}\n   */\n  _processCallbacks (data) {\n    if (!this.callbacks.length) {\n      return false\n    }\n\n    // We've got callbacks, so loop each one and fire it off\n    this.callbacks.forEach(callback => callback(data))\n\n    return true\n  }\n\n  /**\n   * Allow an outside entity to subscribe to state changes with a valid callback.\n   * Returns a function for unsubscription\n   *\n   * @param {function} callback\n   * @returns {function}\n   */\n  subscribe (callback) {\n    if (typeof callback !== 'function') {\n      throw new Error('Dude, you can only subscribe to store changes with a valid function')\n    }\n\n    // create an unsubscribe function\n    const unsubscribe = () => {\n      this.callbacks = this.callbacks.filter(c => c !== callback)\n    }\n\n    // A valid function, so it belongs in our collection\n    if (!this.callbacks.includes(callback)) this.callbacks.push(callback)\n\n    return unsubscribe\n  }\n\n  /**\n   * Copy any value\n   * @param value\n   * @returns {any}\n   * @private\n   */\n  _copyValue (value) {\n    if (!value) return value\n    return JSON.parse(JSON.stringify(value))\n  }\n\n  /**\n   * Clear the store and reset back to the initial state\n   * @param {boolean} notifySubscribers A boolean to indicate if subscribers should be notified\n   * @memberOf Store\n   */\n  clear (notifySubscribers = true) {\n    this.getterCache = {}\n    this.transactionCache = {}\n    this.lastUpdatedState = {}\n\n    // remove any persistence\n    if (this.persist) {\n      this.persist.removeState()\n    }\n\n    // start a transaction\n    this.transaction = true\n    this.status = 'clear'\n\n    // merge the copy of initial state with the current state\n    const initialState = this._copyValue(this.copyOfInitialState)\n    for (const key in initialState) {\n      this.state[key] = initialState[key]\n    }\n\n    this.transaction = false\n    this.status = 'resting'\n\n    if (notifySubscribers) this._processCallbacks(this.state)\n  }\n}\n","export function isPromise (obj) {\n  return (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function'\n}\n"],"names":["BasePersist","constructor","namespace","storage","options","this","_init","globalThis","clearOnReload","entries","performance","getEntriesByType","map","e","type","lastUpdated","includes","removeState","setState","state","setItem","_normalizeState","Date","getTime","toString","saveState","JSON","stringify","getState","getItem","parse","undefined","parseInt","removeItem","Store","self","getterCache","status","transaction","transactionCache","callbacks","_processActions","initialState","copyOfInitialState","_copyValue","ttl","lastUpdatedState","Object","keys","forEach","k","persist","storageName","localStorage","sessionStorage","createPersist","initState","_lastUpdatedTimeDiff","_processState","length","key","bind","Proxy","set","value","_processCallbacks","get","Math","round","stateFn","setter","data","isExistingTransaction","res","obj","then","result","Array","isArray","match","reduce","prevObj","callback","subscribe","Error","push","filter","c","clear","notifySubscribers"],"mappings":"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"}