{"version":3,"file":"app-state.mjs","sources":["../src/base-persist.mjs","../src/with-store.mjs","../src/store.mjs","../src/util/is-promise.mjs","../src/app-state.mjs"],"sourcesContent":["class BasePersist {\n  /**\n   * Create an instance of persistence with the unique namespace identifier\n   * @param {string} namespace\n   * @param {object} storage\n   * @param {object} options\n   */\n  constructor (namespace, storage, options = {}) {\n    this.namespace = namespace\n    this.storage = storage\n    this.options = options\n    this._init()\n  }\n\n  /**\n   * Private method for initializing\n   * @private\n   */\n  _init () {\n    if ('performance' in globalThis && this.options.clearOnReload) {\n      // @ts-ignore\n      const entries = globalThis.performance.getEntriesByType('navigation').map(e => e.type)\n      const lastUpdated = this.lastUpdated()\n      if (lastUpdated && entries.includes('reload')) {\n        this.removeState()\n      }\n    }\n  }\n\n  /**\n   * Set state in the persistence store\n   * @param {*} state\n   */\n  setState (state) {\n    if (state) {\n      this.storage.setItem(`${this.namespace}:state`, this._normalizeState(state))\n      this.storage.setItem(`${this.namespace}:lastUpdated`, new Date().getTime().toString())\n    } else {\n      this.removeState()\n    }\n  }\n\n  /**\n   * Normalize state before persisting\n   * @param state\n   * @returns {string}\n   * @private\n   */\n  _normalizeState (state) {\n    if (typeof state === 'object' && (this.options.saveState && typeof this.options.saveState === 'function')) {\n      return JSON.stringify(this.options.saveState(state))\n    } else if (typeof state !== 'string') {\n      return JSON.stringify(state)\n    }\n    return state\n  }\n\n  /**\n   * Get state from the persistence store\n   * @returns {*}\n   */\n  getState () {\n    const state = this.storage.getItem(`${this.namespace}:state`)\n    return state ? JSON.parse(state) : undefined\n  }\n\n  /**\n   * Get the last updated time in milliseconds since the Unix Epoch\n   * @returns {number}\n   */\n  lastUpdated () {\n    const lastUpdated = this.storage.getItem(`${this.namespace}:lastUpdated`)\n    return lastUpdated ? parseInt(lastUpdated, 10) : undefined\n  }\n\n  /**\n   * Remove state from the persistence store\n   */\n  removeState () {\n    this.storage.removeItem(`${this.namespace}:state`)\n    this.storage.removeItem(`${this.namespace}:lastUpdated`)\n  }\n}\n\n/**\n * Function to create persistence for the store\n * @param {string} namespace\n * @param {string} [storageName]\n * @param {object} [options]\n * @returns {BasePersist}\n */\nfunction createPersist (namespace, storageName = 'session', options) {\n  if (storageName === 'local') {\n    return new BasePersist(namespace, globalThis.localStorage, options)\n  }\n  return new BasePersist(namespace, globalThis.sessionStorage, options)\n}\n\nexport { BasePersist, createPersist }\n","export function withStore (store, options) {\n  return {\n    ...options,\n    created () {\n      // create a subscription callback\n      this._subscribeCallback = () => {\n        // clear the getter cache\n        this.computedCache = {}\n\n        // Run the render processor now that there's changes\n        this._processRender()\n      }\n      this.setStore(store)\n      if (options.created) options.created.call(this)\n    },\n    mounted () {\n      this._subscribeToStores(false)\n      if (options.mounted) options.mounted.call(this)\n    },\n    updated () {\n      this._subscribeToStores(false)\n      if (options.updated) options.updated.call(this)\n    },\n    removed () {\n      this._unsubscribeFromStores()\n      if (options.removed) options.removed.call(this)\n    },\n    setStore (store) {\n      this.store = store\n      this._subscribeToStores()\n    },\n    _subscribeToStores (invokeSubscribeCallback = true) {\n      if (this.store && this.store.subscribe && typeof this.store.subscribe === 'function' && !this.unsubscribe) {\n        this.unsubscribe = this.store.subscribe(this._subscribeCallback)\n        if (invokeSubscribeCallback) this._subscribeCallback()\n      } else if (this.store && typeof this.store === 'object' && !this.store.subscribe) {\n        this.unsubscribe = {}\n        const keys = Object.keys(this.store)\n        keys.forEach(k => {\n          if (this.store[k] && this.store[k].subscribe && typeof this.store[k].subscribe === 'function' && !this.unsubscribe[k]) {\n            this.unsubscribe[k] = this.store[k].subscribe(this._subscribeCallback)\n          }\n        })\n        if (invokeSubscribeCallback) this._subscribeCallback()\n      }\n    },\n    _unsubscribeFromStores () {\n      if (this.store && this.unsubscribe && typeof this.unsubscribe === 'object') {\n        const keys = Object.keys(this.unsubscribe)\n        keys.forEach(k => {\n          this.unsubscribe[k]()\n        })\n        this.unsubscribe = null\n      } else if (this.store && this.unsubscribe && typeof this.unsubscribe === 'function') {\n        this.unsubscribe()\n        this.unsubscribe = null\n      }\n    }\n  }\n}\n","import { createPersist } from './base-persist.mjs'\nimport { isPromise } from './util/is-promise.mjs'\n\nexport class Store {\n  constructor (options) {\n    const self = this\n\n    // An object to hold our state\n    self.state = {}\n\n    // create a getter cache\n    self.getterCache = {}\n\n    // A status enum to set during actions and mutations\n    self.status = 'resting'\n\n    // Transactional flag for batch actions/mutations without triggering re-rendering\n    self.transaction = false\n    self.transactionCache = {}\n\n    // We store callbacks for when the state changes in here\n    self.callbacks = []\n\n    // Allow actions to be added to this instance\n    this._processActions(options)\n\n    // initial state values\n    let initialState = options.initialState || {}\n    self.copyOfInitialState = self._copyValue(initialState)\n\n    // time to live settings\n    self.ttl = -1\n    self.lastUpdatedState = {}\n    if (options.ttl) {\n      self.ttl = options.ttl\n      Object.keys(self.copyOfInitialState).forEach(k => (self.lastUpdatedState[k] = new Date().getTime()))\n    }\n\n    // persistence\n    self.persist = undefined\n    if (options.persist) {\n      self.persist = typeof options.persist === 'string' ? createPersist(options.persist) : options.persist\n\n      // check for initial state\n      const initState = self.persist.getState()\n      const lastUpdated = self.persist.lastUpdated()\n      if (initState &&\n        lastUpdated &&\n        (self.ttl === -1 || self._lastUpdatedTimeDiff(lastUpdated) < self.ttl)) {\n        initialState = initState\n      }\n    }\n\n    // set-up state\n    this._processState(initialState)\n  }\n\n  /**\n   * Attach actions to the store instance\n   * @param {object} options\n   * @private\n   */\n  _processActions (options) {\n    const self = this\n    const keys = Object.keys(options)\n    if (!keys.length) return\n\n    // Run through and bind to the component instance\n    keys.forEach(key => {\n      if (!self[key] && typeof options[key] === 'function') {\n        self[key] = options[key].bind(self)\n      }\n    })\n  }\n\n  /**\n   * Set-up the internal state object\n   * @param {object} initialState\n   * @private\n   */\n  _processState (initialState) {\n    const self = this\n    // Set our state to be a Proxy. We are setting the default state by\n    // checking the params and defaulting to an empty object if no default\n    // state is passed in\n    self.state = new Proxy(initialState, {\n      set (state, key, value) {\n        // cache first value changed if we're in transaction mode\n        if (self.transaction && !self.transactionCache[key]) {\n          self.transactionCache[key] = self._copyValue(state[key])\n        }\n\n        // Set the value as we would normally\n        state[key] = value\n        self.lastUpdatedState[key] = new Date().getTime()\n\n        // clear the getter cache\n        self.getterCache = {}\n\n        if (!self.transaction) {\n          // if we have persistence pass the new state to it\n          if (self.persist) {\n            self.persist.setState(self.state)\n          }\n\n          // Reset the status ready for the next operation\n          self.status = 'resting'\n\n          // Fire off our callback processor because if there's listeners,\n          // they're going to want to know that something has changed\n          self._processCallbacks(self.state)\n        }\n\n        return true\n      },\n      get (state, key) {\n        if (self.ttl > -1 && self._lastUpdatedTimeDiff(self.lastUpdatedState[key]) > self.ttl) {\n          if (self.persist) {\n            self.persist.removeState()\n          }\n          return self.copyOfInitialState[key]\n        }\n        return state[key]\n      }\n    })\n  }\n\n  /**\n   * Last updated state time difference in seconds\n   * @param {number} value\n   * @returns {number}\n   * @private\n   */\n  _lastUpdatedTimeDiff (value) {\n    return Math.round((new Date().getTime() - value))\n  }\n\n  /**\n   * A method to set state\n   * @param {Function} stateFn\n   * @memberOf Store\n   */\n  setState (stateFn) {\n    const setter = data => {\n      if (!data || typeof data !== 'object') return\n\n      const isExistingTransaction = this.transaction\n\n      // begin a transaction\n      if (!isExistingTransaction) {\n        this.transactionCache = {}\n        this.transaction = true\n      }\n\n      for (const key in data) {\n        if (!this.state[key] || (this.state[key] !== data[key])) this.state[key] = data[key]\n      }\n\n      // end the transaction\n      if (!isExistingTransaction) {\n        this.transaction = false\n\n        // if we have persistence pass the new state to it\n        if (this.persist) {\n          this.persist.setState(this.state)\n        }\n\n        this._processCallbacks(this.state)\n      }\n    }\n\n    // Get a new version of the state by running the mutation and storing the result of it\n    const res = stateFn(this.state)\n\n    // set the state\n    isPromise(res) ? res.then(setter) : setter(res)\n  }\n\n  /**\n   * A method to return state\n   * @param {string|function} key\n   * @returns {*}\n   */\n  getState (key) {\n    // if key is not defined\n    if (!key || (typeof key !== 'string' && typeof key !== 'function')) return undefined\n\n    // check the getter cache first\n    if (!this.getterCache[key]) {\n      let result\n      if (typeof key === 'function') {\n        result = key(this.state)\n      } else {\n        // Check if path is string or array. Regex : ensure that we do not have '.' and brackets.\n        // Regex explained: https://regexr.com/58j0k\n        const keyArray = Array.isArray(key) ? key : key.match(/([^[.\\]])+/g)\n\n        // get the result\n        // @ts-ignore\n        result = keyArray.reduce((prevObj, key) => prevObj && prevObj[key], this.state)\n      }\n\n      // if the result is not defined\n      if (result == null) return undefined\n\n      // cache the result\n      this.getterCache[key] = result\n    }\n\n    return this.getterCache[key]\n  }\n\n  /**\n   * Fire off each callback that's run whenever the state changes\n   * We pass in some data as the one and only parameter.\n   * Returns a boolean indicating if the callbacks were called\n   * @private\n   * @param {object} data\n   * @returns {boolean}\n   */\n  _processCallbacks (data) {\n    if (!this.callbacks.length) {\n      return false\n    }\n\n    // We've got callbacks, so loop each one and fire it off\n    this.callbacks.forEach(callback => callback(data))\n\n    return true\n  }\n\n  /**\n   * Allow an outside entity to subscribe to state changes with a valid callback.\n   * Returns a function for unsubscription\n   *\n   * @param {function} callback\n   * @returns {function}\n   */\n  subscribe (callback) {\n    if (typeof callback !== 'function') {\n      throw new Error('Dude, you can only subscribe to store changes with a valid function')\n    }\n\n    // create an unsubscribe function\n    const unsubscribe = () => {\n      this.callbacks = this.callbacks.filter(c => c !== callback)\n    }\n\n    // A valid function, so it belongs in our collection\n    if (!this.callbacks.includes(callback)) this.callbacks.push(callback)\n\n    return unsubscribe\n  }\n\n  /**\n   * Copy any value\n   * @param value\n   * @returns {any}\n   * @private\n   */\n  _copyValue (value) {\n    if (!value) return value\n    return JSON.parse(JSON.stringify(value))\n  }\n\n  /**\n   * Clear the store and reset back to the initial state\n   * @param {boolean} notifySubscribers A boolean to indicate if subscribers should be notified\n   * @memberOf Store\n   */\n  clear (notifySubscribers = true) {\n    this.getterCache = {}\n    this.transactionCache = {}\n    this.lastUpdatedState = {}\n\n    // remove any persistence\n    if (this.persist) {\n      this.persist.removeState()\n    }\n\n    // start a transaction\n    this.transaction = true\n    this.status = 'clear'\n\n    // merge the copy of initial state with the current state\n    const initialState = this._copyValue(this.copyOfInitialState)\n    for (const key in initialState) {\n      this.state[key] = initialState[key]\n    }\n\n    this.transaction = false\n    this.status = 'resting'\n\n    if (notifySubscribers) this._processCallbacks(this.state)\n  }\n}\n","export function isPromise (obj) {\n  return (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function'\n}\n","import { createPersist } from './base-persist.mjs'\nimport { withStore } from './with-store.mjs'\nimport { Store } from './store.mjs'\n\n/**\n * Function to create a store instance\n * @param {string} key\n * @param {object} options\n * @returns {Store}\n */\nfunction createAppState (key, options) {\n  let store = getAppState(key)\n  if (store) return store\n  store = new Store(options)\n  globalThis.__ficusjs__ = globalThis.__ficusjs__ || {}\n  globalThis.__ficusjs__.store = globalThis.__ficusjs__.store || {}\n  globalThis.__ficusjs__.store[key] = store\n  return store\n}\n\n/**\n * Function to retrieve a Store instance\n * @param {string} key\n * @returns {Store|undefined}\n */\nfunction getAppState (key) {\n  if (globalThis.__ficusjs__ && globalThis.__ficusjs__.store && globalThis.__ficusjs__.store[key]) {\n    return globalThis.__ficusjs__.store[key]\n  }\n}\n\nexport { createAppState, getAppState, createPersist, withStore }\n"],"names":["BasePersist","constructor","namespace","storage","options","this","_init","globalThis","clearOnReload","entries","performance","getEntriesByType","map","e","type","lastUpdated","includes","removeState","setState","state","setItem","_normalizeState","Date","getTime","toString","saveState","JSON","stringify","getState","getItem","parse","undefined","parseInt","removeItem","createPersist","storageName","localStorage","sessionStorage","withStore","store","created","_subscribeCallback","computedCache","_processRender","setStore","call","mounted","_subscribeToStores","updated","removed","_unsubscribeFromStores","invokeSubscribeCallback","subscribe","unsubscribe","Object","keys","forEach","k","Store","self","getterCache","status","transaction","transactionCache","callbacks","_processActions","initialState","copyOfInitialState","_copyValue","ttl","lastUpdatedState","persist","initState","_lastUpdatedTimeDiff","_processState","length","key","bind","Proxy","set","value","_processCallbacks","get","Math","round","stateFn","setter","data","isExistingTransaction","res","obj","then","result","Array","isArray","match","reduce","prevObj","callback","Error","push","filter","c","clear","notifySubscribers","createAppState","getAppState","__ficusjs__"],"mappings":"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"}